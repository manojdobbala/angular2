/**
 * testing utilities for Mocha
 * Original: https://github.com/angular/angular/blob/master/modules/angular2/src/testing/testing.ts
 */
"use strict";
var lang_1 = require("@angular/core/src/facade/lang");
var test_injector_1 = require("../core/test_injector");
var _global = (typeof window === "undefined" ? lang_1.global : window);
/**
 * Run a function (with an optional asynchronous callback) after each test case.
 *
 * See http://jasmine.github.io/ for more details.
 *
 * ## Example:
 *
 * {@example testing/ts/testing.ts region='afterEach'}
 */
exports.afterEach = _global.afterEach;
/**
 * Group test cases together under a common description prefix.
 *
 * See http://jasmine.github.io/ for more details.
 *
 * ## Example:
 *
 * {@example testing/ts/testing.ts region='describeIt'}
 */
exports.describe = _global.describe;
/**
 * Like {@link describe}, but instructs the test runner to exclude
 * this group of test cases from execution. This is useful for
 * debugging, or for excluding broken tests until they can be fixed.
 */
exports.xdescribe = _global.xdescribe;
var mochaBeforeEach = _global.beforeEach;
var mochaIt = _global.it;
var mochaXIt = _global.xit;
var testInjector = test_injector_1.getTestInjector();
// Reset the test providers before each test
mochaBeforeEach(function () {
    testInjector.reset();
});
/**
 * Allows overriding default providers defined in test_injector.js.
 *
 * The given function must return a list of DI providers.
 *
 * Example:
 *
 *   beforeEachProviders(() => [
 *     provide(Compiler, {useClass: MockCompiler}),
 *     provide(SomeToken, {useValue: myValue}),
 *   ]);
 */
function beforeEachProviders(fn) {
    mochaBeforeEach(function () {
        var providers = fn();
        if (!providers)
            return;
        try {
            testInjector.addProviders(providers);
        }
        catch (e) {
            throw new Error('beforeEachProviders was called after the injector had ' +
                'been used in a beforeEach or it block. This invalidates the ' +
                'test injector');
        }
    });
}
exports.beforeEachProviders = beforeEachProviders;
function _wrapTestFn(fn) {
    // Wraps a test or beforeEach function to handle synchronous and asynchronous execution.
    return function (done) {
        if (fn.length === 0) {
            var retVal = fn();
            if (lang_1.isPromise(retVal)) {
                // Asynchronous test function - wait for completion.
                retVal.then(function () { return done(); }, done);
            }
            else {
                // Synchronous test function - complete immediately.
                done();
            }
        }
        else {
            // Asynchronous test function that takes "done" as parameter.
            fn(done);
        }
    };
}
function _it(mochaFn, name, testFn) {
    mochaFn(name, _wrapTestFn(testFn));
}
/**
 * Wrapper around Mocha beforeEach function.
 *
 * beforeEach may be used with the `inject` function to fetch dependencies.
 */
function beforeEach(fn) {
    mochaBeforeEach(_wrapTestFn(fn));
}
exports.beforeEach = beforeEach;
/**
 * Define a single test case with the given test name and execution function.
 *
 * The test function can be either a synchronous function, the result of {@link async},
 * or an injected function created via {@link inject}.
 *
 * Wrapper around Mocha it function.
 */
function it(name, fn) {
    return _it(mochaIt, name, fn);
}
exports.it = it;
/**
 * Like {@link it}, but instructs the test runner to exclude this test
 * entirely. Useful for debugging or for excluding broken tests until
 * they can be fixed.
 *
 * Wrapper around Mocha xit function.
 */
function xit(name, fn) {
    return _it(mochaXIt, name, fn);
}
exports.xit = xit;
